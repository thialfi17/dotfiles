local M = {}

---@param path string Path with optional wildcards to scan and generate a list of paths
---@param filter? fun(name: string, type: string) Function used to filter path results based on item path and type
---@return function|nil iter Iterator that returns each path valid path generated by wildcards and filter
M.scan_path_iter = function(path, filter)
    -- Find the first *
    local _, e, path_start = path:find("([^%*]+)%*")

    -- If no '*'s then return the whole path
    if path_start == nil then
        -- Check if dir exists: if not exit early.
        if vim.uv.fs_stat(path) == nil then
            return nil
        end

        local once = true
        -- Return a function to keep user interface the same to allow `for x in ...`
        return function()
            if once then
                once = false
                return path
            end
        end
    end

    -- TODO: Can these calls be simplified/combined?

    -- Get the base directory of the pattern
    local base_dir = path_start:match("(.*/)")
    -- Get the prefix of the file/dir before the '*'
    local prefix = "^" .. path_start:match(".*/(.*)")
    -- Get the part of the path after the '*'
    local path_remaining = path:sub(e + 1)

    -- Check if base_dir exists - if not exit early
    if vim.uv.fs_stat(base_dir) == nil then
        return nil
    end

    -- Create the uv iterator and check it was created
    local dir_iter = vim.uv.fs_scandir(base_dir)
    if dir_iter == nil then
        return nil
    end

    -- Need to track results from recursive calls so we can iterate through
    -- those as well as our own results
    local nested_iter
    local function process_nested()
        for v in nested_iter do
            return v
        end
        nested_iter = nil
    end

    return function()
        -- Process results from recursive calls
        if nested_iter ~= nil then
            local v = process_nested()
            if v ~= nil then return v end
        end

        for name, ftype in vim.uv.fs_scandir_next, dir_iter, 0 do
            -- Check current result prefix matches
            if name:match(prefix) then
                local full_path = base_dir .. name
                -- Apply external filter if given
                if filter == nil or filter(full_path, ftype) then
                    -- If there's remaining stuff in the path then attempt to
                    -- parse any remaining wildcards
                    if path_remaining ~= "" then
                        local res = M.scan_path_iter(full_path .. path_remaining, filter)
                        if res then
                            nested_iter = res
                            local v = process_nested()
                            if v ~= nil then return v end
                        end
                        -- If no results then falls through to next item in for loop
                    else
                        return full_path
                    end
                end
            end
        end
    end
end

return M
